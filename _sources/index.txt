
Pyadjoint
=========

``Pyadjoint`` is a Python package to measure misfits and calculate
adjoint sources. It aims to provide a comprehensive package and
incorporate various types of measurements and associated adjoint
sources.

Installation
------------

``Pyadjoint`` utilizes `ObsPy <http://obspy.org>`_ (and some of its
dependencies) for the processing and data handling. As a first step,
please follow the `installation instructions of
ObsPy <https://github.com/obspy/obspy/wiki#installation>`_ for your
given platform (we recommend the installation with
`Anaconda <https://github.com/obspy/obspy/wiki/Installation-via-Anaconda>`_
as it will most likely result in the least amount of problems).
``Pyadjoint`` should work with Python versions 2.7, 3.3, and 3.4 (mainly
depends on the used ObsPy version). To install it, best use ``pip`` (not
working yet!):

::

    $ pip install pyadjoint

If you want the latest development version, or want to work on the code,
you will have to install with the help of ``git``.

::

    $ git clone https://github.com/krischer/pyadjoint.git
    $ cd pyadjoint
    $ pip install -v -e .

Tests
-----

To assure the installation is valid and everything works as expected,
run the tests with

::

    $ python -m pyadjoint.tests

Usage
-----

Basic Usage
~~~~~~~~~~~

The first step is to import ObsPy and ``Pyadjoint``.

.. code:: python

    import obspy
    import pyadjoint


::


    ---------------------------------------------------------------------------

    RuntimeError                              Traceback (most recent call last)

    RuntimeError: module compiled against API version a but this version of numpy is 9


::


    ---------------------------------------------------------------------------

    ImportError                               Traceback (most recent call last)

    <ipython-input-1-09b481244fd7> in <module>()
          1 import obspy
    ----> 2 import pyadjoint
    

    /home/travis/build/krischer/pyadjoint/src/pyadjoint/__init__.py in <module>()
         32 
         33 # Main objects and functions available at the top level.
    ---> 34 from .adjoint_source import AdjointSource, calculate_adjoint_source  # NOQA
    

    /home/travis/build/krischer/pyadjoint/src/pyadjoint/adjoint_source.py in <module>()
         13 
         14 import inspect
    ---> 15 import matplotlib.pylab as plt
         16 import numpy as np
         17 import obspy


    /home/travis/miniconda/envs/condaenv/lib/python3.4/site-packages/matplotlib/pylab.py in <module>()
        229 # make mpl.finance module available for backwards compatability, in case folks
        230 # using pylab interface depended on not having to import it
    --> 231 import matplotlib.finance
        232 
        233 from matplotlib.dates import date2num, num2date,\


    /home/travis/miniconda/envs/condaenv/lib/python3.4/site-packages/matplotlib/finance.py in <module>()
         34 
         35 from matplotlib import verbose, get_cachedir
    ---> 36 from matplotlib.dates import date2num
         37 from matplotlib.cbook import iterable, mkdirs
         38 from matplotlib.collections import LineCollection, PolyCollection


    /home/travis/miniconda/envs/condaenv/lib/python3.4/site-packages/matplotlib/dates.py in <module>()
        135 import matplotlib.units as units
        136 import matplotlib.cbook as cbook
    --> 137 import matplotlib.ticker as ticker
        138 
        139 


    /home/travis/miniconda/envs/condaenv/lib/python3.4/site-packages/matplotlib/ticker.py in <module>()
        156 from matplotlib import rcParams
        157 from matplotlib import cbook
    --> 158 from matplotlib import transforms as mtransforms
        159 
        160 


    /home/travis/miniconda/envs/condaenv/lib/python3.4/site-packages/matplotlib/transforms.py in <module>()
         37 import numpy as np
         38 from numpy import ma
    ---> 39 from matplotlib._path import (affine_transform, count_bboxes_overlapping_bbox,
         40     update_path_extents)
         41 from numpy.linalg import inv


    ImportError: numpy.core.multiarray failed to import


``Pyadjoint`` expects the data to be fully preprocessed thus both
observed and synthetic data are expected to have exactly the same
length, sampling rate, and spectral content. ``Pyadjoint`` furthermore
does not care about the actual components in question; it will use two
traces and calculate misfit values and adjoint sources for them. To
provide a familiar nomenclature we will always talk about observed and
synthetic data ``Pyadjoint`` is independent of what the data actually
represents.

.. code:: python

    # Helper function to get some example data used for
    # illustrative purposes.
    obs, syn = pyadjoint.utils.get_example_data()
    # Select the vertical components of both.
    obs = obs.select(component="Z")[0]
    syn = syn.select(component="Z")[0]


Essentially all of ``Pyadjoint``'s functionality is accessed through its central :func:`~pyadjoint.adjoint_source.calculate_adjoint_source` function. A list of available
adjoint source types can be found in :doc:`adjoint_sources/index`.



.. code:: python

    adj_src = pyadjoint.calculate_adjoint_source(
        # The type of misfit measurement and adjoint source.
        adj_src_type="waveform_misfit",
        # Pass observed and synthetic data traces.
        observed=obs, synthetic=syn,
        # The spectral content of the data.
        min_period=20.0, max_period=100.0,
        # The window borders in seconds since the first sample.
        left_window_border=800.0,
        right_window_border=900.0)
    print(adj_src)


It returns an :class:`~pyadjoint.adjoint_source.AdjointSource` object.



.. code:: python

    # Access misfit and adjoint sources. The misfit is a floating point number.
    print(adj_src.misfit)
    # The adjoint source is a a numpy array.
    print(adj_src.adjoint_source)

Usage Options
~~~~~~~~~~~~~

In case one just wants to calculate the misfit value, pass
``adjoint_src=False`` in which case the adjoint source will not be
calculated. This sometimes is much faster and useful for line searches
or similar endeavors.

.. code:: python

    print(pyadjoint.calculate_adjoint_source(
        adj_src_type="waveform_misfit", observed=obs, synthetic=syn,
        min_period=20.0, max_period=100.0,
        left_window_border=800.0, right_window_border=900.0, adjoint_src=False))

All adjoint source types can also be plotted during the calculation. The
type of plot produced depends on the type of misfit measurement and
adjoint source.

.. code:: python

    pyadjoint.calculate_adjoint_source(
        adj_src_type="waveform_misfit", observed=obs, synthetic=syn,
        min_period=20.0, max_period=100.0,
        left_window_border=800.0, right_window_border=900.0, plot=True);


Many types of adjoint sources have additional arguments that can be passed to it. The waveform misfit adjoint source for example allows to specifiy the width and type of the taper applied to the data. Please see the documentation of the different :doc:`adjoint_sources/index` for details.



.. code:: python

    print(pyadjoint.calculate_adjoint_source(
        adj_src_type="waveform_misfit", observed=obs, synthetic=syn,
        min_period=20.0, max_period=100.0,
        left_window_border=800.0, right_window_border=900.0,
        taper_percentage=0.3, taper_type="cosine"))

Saving to Disc
~~~~~~~~~~~~~~


One of course wants to serialize the calculated adjoint sources to disc at one point in time. You need to pass the filename and the desired format as well as some format specific parameters to the :meth:`~pyadjoint.adjoint_source.AdjointSource.write` method of the :class:`~pyadjoint.adjoint_source.AdjointSource` object. Instead of a filename you can also pass an open file or a file-like object. Please refer to its documentation for more details.



.. code:: python

    adj_src.write(filename="NET.STA.CHA.adj_src",
                  format="SPECFEM", time_offset=-10)

.. code:: python

    !head NET.STA.CHA.adj_src
    !rm NET.STA.CHA.adj_src


Detailed Documentation
----------------------

Further Pages
~~~~~~~~~~~~~


.. toctree::
    :maxdepth: 2

    adjoint_sources/index
    example_dataset
    citations
    how_to_add_a_new_adjoint_source
    


API
~~~

.. toctree::
    :maxdepth: 2
    
    adjoint_source
    utils



